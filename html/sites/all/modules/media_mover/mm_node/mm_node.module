<?php
// $Id: mm_node.module,v 1.17 2008/02/29 22:10:26 bdragon Exp $

/**
 * This file implements media mover functions related to nodes
 */

/**
 * Implementation of media_mover hook
 * @param $op is the operator to return
 * @param $action is which action is being called
 * @param $verb is the verb being run
 * @param $configuration is the specific configuration saved for the action for this configuration
 * @param $item Media mover item being processed.
 * @param $running_config is the full configuration data currently running
 */
function mm_node_media_mover($op, $action = null, $configuration = null, &$item = array(), $running_config = null) {
  switch ($op) {
    // give your module a distinct name
    case 'name':
      return 'Media Mover node module';

    // defines the actions that this module does
    // these are numbered for easy identification of what
    // action is being called
    case 'actions':
      return array(
        'harvest' => array(
          1 => t('Harvest from another Media Mover configuration'),
          2 => t('Select drupal uploaded files'),
        ),
        'storage' => array(
          4 => t('Save data as a node'),
          5 => t('Attach processed file to node'),
        ),
        'complete' => array(
          3 => t('Set node status'),
        )
      );

    // create edit configuration option set
    // $action is used to ensure namespacing is kept consistent, for
    // $configuration is an array, settings stored on a per config basis
    case 'config':
      switch ($action) {
        // select media mover uploaded files
        case '1':
          return mm_node_config_harvest_mm($action, $configuration, $running_config);
        break;

        // select_drupal_uploaded_files
        case '2':
          return mm_node_config_harvest($action, $configuration, $running_config);
        break;

        // this calls the completion
        case '3':
          return mm_node_config_complete($action, $configuration);
        break;

        // this calls the storage
        case '4':
          return mm_node_config_save_node($action, $configuration);
        break;

        case '5':
          return mm_node_config_attach_file($action, $configuration);
        break;
      }
      break;

    // defines what type of driver this module is
    // array of harvest, process, storage, complete
    // a module may operate more than one verb
    case 'verbs':
      return array('harvest', 'storage', 'complete');

    // functions called on harvest op
    // returns an array of $files
    case 'harvest':
      switch ($action) {
        case '1':
          return mm_node_harvest_mm_files($configuration, $running_config);
        case '2':
          return mm_node_harvest($configuration, $running_config);
      }
      break;

    // functions called on storage op
    case 'storage':
      switch ($action) {
        case '4':
          return mm_node_node_save($item, $configuration);

        // save file to node attachments
        case '5':
          return mm_node_attach_file($item, $configuration);
      }
      break;

    // functions called on completion
    case 'complete':
      switch ($action) {
        case '3':
          return mm_node_complete($configuration, $item);
      }
      break;

    // custom theme a file assoicated with this module
    case 'theme':
      break;

    // implements a delete call from media mover
    case 'delete':
      switch ($action) {
        // this calls the storage
        case '4':
          return;

        case '5':
dpm('FOO TIME');
dpm($item);
return;
          return mm_node_attach_file_delete($item, $running_config);
      }
      break;
  }
}

/* ************************************************ */
/* Media Mover: Media Mover hook  functions */
/* ************************************************ */

/**
 * Harvest from uploaded files on specific node types.
 * @param $configuration Configuration settings for this action.
 * @param $running_config Configuration settings for entire config.
 * @return A list of "harvested" files.
 */
function mm_node_harvest($configuration, $running_config) {
  $files = array();

  $types = array();
  foreach ($configuration['mm_node_types'] as $type) {
    if ($type) {
      $types[] = $type;
    }
  }

  // Put together the list of allowed file extensions.
  $extensions = explode(',', $configuration['file_types']);
  foreach ($extensions as $k => $v) {
    $extensions[$k] = trim(strtolower($v));
  }
  $extensions = drupal_map_assoc($extensions);

  // 'All arguments in one array' syntax.
  $args = $types;
  array_unshift($args, $configuration['cid']);

  // Get the files of those types that haven't been harvested yet.
  // The trick here is the left join on media_mover_files and the IS NULL check.
  // It is possible for multiple configurations to harvest the same file.
  $results = db_query('
SELECT f.*, u.nid FROM {files} f
INNER JOIN {upload} u ON f.fid = u.fid
LEFT JOIN {media_mover_files} m ON f.fid = m.fid AND m.cid = %d
LEFT JOIN {node} n ON u.nid = n.nid
WHERE m.fid IS NULL
AND f.status = 1
AND n.type IN ('. db_placeholders($types, 'varchar') .')', $args);

  while ($row = db_fetch_array($results)) {
    // Check if the file is in the allowed extensions list.
    if (array_key_exists(strtolower(pathinfo($row['filepath'], PATHINFO_EXTENSION)), $extensions)) {
      // Check if the file is actually on the filesystem.
      if (file_exists($row['filepath'])) {
        // Add file to harvested list.
        $row['harvest']['file'] = $row['filepath'];
        $files[] = $row;
      }
    }
  }
  return $files;
}

/**
 * Harvest from media mover files.
 * @param $configuration Configuration settings for this action.
 * @param $running_config Configuration settings for entire config.
 * @return A list of "harvested" files.
 */
function mm_node_harvest_mm_files($configuration, $running_config) {
  $files = array();
  // @@@ GENERAL FIXUP NEEDED.
  // get files from the requested CID, that were posted more recently than the last time this config ran.
  $results = db_query('SELECT complete_file, nid FROM {media_mover_files} WHERE cid = %d AND date > %d', $configuration['mm_harvest_cid'], $running_config->last_start_time);
  while ($result = db_fetch_array($results)) {
    $file['harvest']['file'] = $result['complete_file'];
    $file['nid'] = $result['nid'];
    $files[] = $file;
  }
  return $files;
}

/**
 * Change an affected node's workflow status.
 * @param $configuration Configuration settings for this action.
 * @param $item A media_mover item.
 */
function mm_node_complete($configuration, $item) {
  // @@@ $item['nid'] moving somewhere else?
  $options = array();
  if ($configuration['complete_conditions']['published'] != '0') { $options[] = "status = 1 ";}
  if ($configuration['complete_conditions']['in moderation queue'] != '0') { $options[] = "moderate = 1 ";}
  if ($configuration['complete_conditions']['promoted to front page'] != '0') { $options[] = "promote = 1 ";}
  if (count($options)) {
    $options = implode(', ', $options);
    db_query('UPDATE {node} SET '. $options .'WHERE nid = %d', $item['nid']);
  }
}

/**
 * stores the actual data as a node
 * @ TODO finish up this functionality to deploy
 *        requires creating the data store
 */
function mm_node_node_save(&$item, $configuration) {

  // Set up the pseudo node object for drupal_execute()ing.
  $edit = array();

  // If earlier steps put together the start of a node object, us it.
  if (is_array($item['node'])) {
    $edit = $item['node'];
  }

  // Set type.
  if (!isset($edit['type'])) {
    $edit['type'] = $configuration['node_save_type'];
  }

  // If the user is being overridden, load it.
  if ($configuration['node_save_override']) {
    $account = user_load(array('name' => $configuration['node_save_name']));
    $edit['uid'] = $account->uid;
    $edit['name'] = $account->name;
  }
  else if (!isset($edit['uid'])) {
    if ($item['uid']) {
      $account = user_load(array('uid' => $item['uid']));
      $edit['uid'] = $account->uid;
      $edit['name'] = $account->name;
    }
    else {
      $edit['uid'] = 0;
      $edit['name'] = variable_get('anonymous', 'Anonymous');
    }
  }

  // If there still isn't a user name yet, figure it out.
  if (!isset($edit['name'])) {
    $account = user_load(array('uid' => $edit['uid']));
    $edit['name'] = $account->name;
  }

  // i18n
  if (!isset($edit['language'])) {
    $edit['language'] = '';
  }

  // Figure out the title.
  if ($configuration['node_save_override']) {
    $edit['title'] = $configuration['node_title_default'];
  }
  else if (!isset($edit['title'])) {
    $edit['title'] = $configuration['node_title_default'];
  }

  // Figure out the body.
  if (!isset($edit['body'])) {
    // @@@ I disagree completely with this..
    // @@@ Fallback body?
    $edit['body'] = t('This was uploaded without any additional information');
  }

  $node_type_default = variable_get('node_options_'. $edit['type'], array('status', 'promote'));
  if (!isset($edit['promote'])) $edit['promote'] = in_array('promote', $node_type_default);
  if (!isset($edit['comment'])) $edit['comment'] = variable_get('comment_'. $edit['type'], 2);
  if (!isset($edit['revision'])) $edit['revision'] = in_array('revision', $node_type_default);
  if (!isset($edit['format'])) $edit['format'] = FILTER_FORMAT_DEFAULT;

  if (!isset($edit['status'])) {
    $edit['status'] = 1; // @@@
  }

  node_invoke_nodeapi($edit, 'media mover new');
  node_validate($edit);
  if ($errors = form_get_errors()) {
    // @@@ Bail!
  }

  // @@@ D6 port -- This isn't the right way to do it anymore.

  $node = node_submit($edit);
  node_save($node);
  if (!$node->nid) {
    // @@@ Bail!
  }

  //@@@ Confusing between original node and created node....
  // This is the *created* node here...
  // Note: This was in the if block below, but was causing zeros in the final
  // table if you were relying only on the "built in" association of media_mover_files
  // to nodes!
  $item['nid'] = $node->nid;

  // Should we save the item as a drupal file and attach it?
  if ($configuration['node_save_files']) {
    // add the storage data back to the file
    $item['storage']['file'] = $item['data']['file']['drupal_path'];
    mm_node_attach_file($item, $configuration);
  }
  else {
    // @@@ Shouldn't have to do this!
    $item['storage']['file'] = $item['process']['file'];
  }
}

/**
 * Attach an incoming file to an existing node.
 * @param $item A media mover item.
 * @param $configuration is this functions configuration
 * @return $file array
 */
function mm_node_attach_file(&$item, $configuration) {
  if ($item['process']['local']) {

    $fileobj = new stdClass();
    $fileobj->uid = $item['uid'];
    $fileobj->filename = basename($item['process']['file']);
    $fileobj->filepath = $item['process']['file'];
    $fileobj->filemime = $item['mime'];
    $fileobj->filesize = filesize($item['process']['file']);
    drupal_write_record('files', $fileobj);

    $upload = new stdClass();
    $upload->fid = $fileobj->fid;
    $upload->nid = $item['nid'];
    $upload->list = $configuration['list'];
    $upload->description = basename($item['process']['file']); // @@@ This should probabaly be more like "Automatic conversion: bla" or something. Theme()?
    if (!empty($configuration['description'])) {
      $upload->description = $configuration['description'];
    }

    $result = db_query('SELECT vid FROM {node_revisions} WHERE nid = %d', $item['nid']);
    while ($row = db_fetch_object($result)) {
      // We need to attach to each revision. So, loop over the node's revisions and make a record for each.
      $upload->vid = $row->vid;
      drupal_write_record('upload', $upload);
      // @@@ Is there some sort of hook we should call here?
    }

    // Reuse the process file.
    $item['storage']['file'] = $item['process']['file'];
    $item['data']['storage']['fid'] = $fileobj->fid;
  }
}

/**
 * removes references to files from files table where they were
 * stored
 */
function mm_node_attach_file_delete($item, $config) {
  if ($item['data'])

  // get all the files for this config
  $files = media_mover_api_fetch_files($running_config->cid);

  foreach ($files as $file) {
    //file_set_status($file['storage_file'], FILE_STATUS_TEMPORARY);
    // @TODO delete the file from the files db table
    // db_queryd('DELETE * FROM {files} WHERE filepath = "%s"', $file['storage_file']);
    // delete the actual file
    if (is_file($file['storage']['file'])) {
       $fh = fopen($file['storage']['file'], 'w') or die("can't open file"); // @@@ This is not nice.
       fclose($fh);
        if (unlink( $file['storage']['file'])) {
          print "deleted";

        }
        else {
          print "not deleted";
        }

      if (unlink($file['storage']['file'])) {
      //  print "deleted ". $file['storage_file'] ."\n\n";
      }
      else {
        //print "could not delete: ". $file['storage_file'] . "\n\n";
      }
    }
  }
}


/* ************************************************** */
/* Media Mover: Media Mover config & admin  functions */
/* ************************************************** */


/**
 * configuration options for attaching a file to a node
 */
function mm_node_config_attach_file($action_id, $configuration) {
  $form['mm_attach_file'] = array(
    '#title' => t('Attach processed file to node'),
    '#type' => 'fieldset',
    '#collapsed' => false,
  );
  $form['mm_attach_file']['list'] = array(
    '#title' => t('List file'),
    '#type' => 'checkbox',
    '#description' => t('Check this box to "list" the stored file.'),
    '#default_value' => isset($configuration['list']) ? $configuration['list'] : TRUE,
  );
  $form['mm_attach_file']['description'] = array(
    '#title' => t('Force description'),
    '#type' => 'textfield',
    '#description' => t('Enter a file description to use here, or leave blank to use the filename.'),
    '#default_value' => isset($configuration['description']) ? $configuration['description'] : '',
  );
  return $form;
}

/**
 * Config config form for media mover
 * creates the options for each configuration instance
 *
 * NOTE: name form files like: ["db_options"]
 * so that they are processed correctly on the add configuration
 * screen
 */
function mm_node_config_harvest($action_id, $configuration) {

  $form['mm_harvest_conf'] = array(
    '#type' => 'fieldset',
    '#title' => t('Harvest Configuration'),
    '#description' => t('This module harvests files attached to nodes that have been created on the site.'),
    '#collapsed' => false,
  );

  foreach (node_get_types() as $type) {
    $node_types[$type->type] = $type->name;
  }

  $form['mm_harvest_conf']['mm_node_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Select files from these content types'),
    '#description' => t('Select content types you wish to search for video files to convert.'),
    '#options' => $node_types,
    '#default_value' => isset($configuration['mm_node_types']) ? $configuration['mm_node_types'] : array(),
    '#required' => TRUE,
  );

  $form['mm_harvest_conf']['file_types'] = array(
    '#title' => t('File types'),
    '#type' => 'textfield',
    '#default_value' => $configuration['file_types'] ? $configuration['file_types'] : 'avi,mov,wmv,mpeg,mp4,mpeg2,dv,3gp,3g2,mpeg4',
    '#description' => t('Comma seperated list of file types that can be harvested. These are file extensions and are values like "avi,mov,wmv,mpeg,mp4,mpeg2,dv".'),
    '#required' => TRUE,
    );
  return $form;
}

/**
 * Configuration for harvesting files from media mover files
 * @param $action_id is the action name
 * @param $configuration is the configuration being passed in for edit
 */
function mm_node_config_harvest_mm($action_id, $configuration) {
  $form = array();

  $form['mm_harvest_conf_mm'] = array(
    '#type' => 'fieldset',
    '#title' => t('Harvest from Media Mover files'),
    '#description' => t('This harvests files that Media Mover has created.'),
    '#collapsed' => false,
  );

  $mmm_configs = _mm_get_active_configurations();
  foreach ($mmm_configs as $mmm_config ) {
    $options[$mmm_config->cid] = t('Media Mover: ') . $mmm_config->name;
  }

  // you can't harvest from your on harvest op
  if ($configuration['cid']) {
    unset($options[$configuration['cid']]);
  }

  $form['mm_harvest_conf_mm']['mm_harvest_cid'] = array(
    '#title' => t('Harvest files from configuration'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => $configuration['mm_harvest_cid'],
  );

  return $form;
}

/**
 * Config config form for media mover
 * creates the options for each configuration instance
 *
 */
function mm_node_config_complete($action, $configuration) {
  $form['complete'] = array(
    '#type' => 'fieldset',
    '#title' => t('Completion Configuration'),
    '#collapsed' => false,
  );

  $options = array('published' => t('Published'), 'in moderation queue' => t('In moderation queue'), 'promoted to front page' => t('Promoted to front page'));
  $form['complete']['complete_conditions'] = array(
    '#title' => t('Completion condition'),
    '#type' => 'checkboxes',
    '#options' => $options,
    '#default_value' => $configuration['complete_conditions'],
    '#description' => t('Set the status of the node post completion'),
    );
  return $form;
}

/**
 * config form for the storage option
 */
function mm_node_config_save_node($action, $configuration) {

  // get node types
  $types = node_get_types();

  foreach ($types as $type) {
    $options[$type->type] = $type->name;
  }

  $form['storage'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node storage configuration'),
    '#collapsed' => false,
    '#description' => t('This module will try to do a best guess of harvested data and save this to a node.'),
  );

  $form['storage']['node_save_type'] = array(
    '#title' => t('Default node type'),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => $configuration['node_save_type'],
    '#description' => t('Save the harvested and processed data on this node type'),
  );

  // get list of all profile fields
  if (module_exists('profile')) {
    $profiles = array('' => t('none'));
    $fields = db_query('SELECT * FROM {profile_fields} ORDER BY category, weight');
    while ($field = db_fetch_array($fields)) {
      $profiles[$field['fid']] = $field['title'];
    }
    $form['storage']['node_save_profile'] = array(
      '#title' => t('Map from address to user field'),
      '#type' => 'select',
      '#options' => $profiles,
      '#default_value' => $configuration['node_save_profile'],
      '#description' => t('This setting will attempt to map the from address of an email to a specific profile phone field. This will be used only if the from address doesn\'t match any Druapl users\' email addresses.'),
    );
  }

  $form['storage']['node_save_files'] = array(
    '#title' => t('Save files to node attachments'),
    '#type' => 'checkbox',
    '#default_value' => $configuration['node_save_files'] ,
    '#description' => t('If this is checked, all files harvested will be attached to the node (and potentially visable to users). If not, files will be accessible via Media Mover.'),
  );
// Copied from other action...
  $form['storage']['mm_attach_file'] = array(
    '#title' => t('Attach processed file to node'),
    '#type' => 'fieldset',
    '#collapsed' => false,
  );
  $form['storage']['mm_attach_file']['list'] = array(
    '#title' => t('List file'),
    '#type' => 'checkbox',
    '#description' => t('Check this box to "list" the stored file.'),
    '#default_value' => isset($configuration['list']) ? $configuration['list'] : TRUE,
  );
  $form['storage']['mm_attach_file']['description'] = array(
    '#title' => t('Force description'),
    '#type' => 'textfield',
    '#description' => t('Enter a file description to use here, or leave blank to use the filename.'),
    '#default_value' => isset($configuration['description']) ? $configuration['description'] : '',
  );


  $form['storage']['node_save_override'] = array(
    '#title' => t('Data override'),
    '#type' => 'checkbox',
    '#default_value' => $configuration['node_save_override'] ,
    '#description' => t('If this is checked, all saved nodes will have the title an author set below.'),
  );

  $form['storage']['node_save_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Default author'),
    '#maxlength' => 60,
    '#autocomplete_path' => 'user/autocomplete',
    '#default_value' => $configuration['node_save_name'] ? $configuration['node_save_name'] : 'anonymous',
    '#description' => t('If a user is not passed in, this will be the default author.'),
  );

  $form['storage']['node_title_default'] = array(
    '#type' => 'textfield',
    '#title' => t('Default title'),
    '#maxlength' => 60,
    '#default_value' => $configuration['node_title_default'],
    '#description' => t('If a title is not passed in, this will be the default node title.'),
  );
  return $form;
}
