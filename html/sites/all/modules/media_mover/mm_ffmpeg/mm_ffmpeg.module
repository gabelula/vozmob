<?php
// $Id: mm_ffmpeg.module,v 1.19 2008/03/11 19:42:59 bdragon Exp $

/**
 * @file
 * Media Mover ffmpeg interface.
 */

/**
 * @ TODO lots of configuration fixes
 * @ TODO error checking on ffmpeg
 * @ TODO have somebody build a nice compiled version of ffmpeg
 */

/**
 * Implementation of hook_media_mover().
 */
function mm_ffmpeg_media_mover($op, $action_id = null, $configuration = array(), &$item = array()) {
  switch ($op) {
    case 'name':
      return 'FFmpeg module';
      break;

    // edit a configuration option set
    // $type is needed to build out options, is "type:action"
    // $configuration is passed in from db
    case 'config':
      switch ($action_id) {
        case '1': //convert video
          return mm_ffmpeg_config($action_id, $configuration);
        case '2': //create thumbnail from video
          return mm_ffmpeg_config_thumb($action_id, $configuration);
      }
      break;

    case 'admin':
      return mm_ffmpeg_admin();

    // defines what type of driver this module is
    // harvest, process, storage
    case 'verbs':
      return array('process');

    case 'actions':
      return array(
        'process' => array(
          1 => 'convert video',
          2 => 'create thumbnail from video',
        ),
      );

    case 'directories':
      return array('ffmpeg/converted', 'ffmpeg/thumbnails');

    case 'process':
      switch ($action_id) {
        case '1': //convert video
          return _mm_ffmpeg_video($item, $configuration);
        case '2': //create thumbnail from video
          return _mm_ffmpeg_video_thumbnail($item, $configuration);
      }
      break;
  }
}

/* ************************************ */
/* conversion functions */
/* ************************************ */

/**
 * create the thumbnail
 * @param $file is a full file array
 * @param $configuration is a configuration array
 * @return modifield file array
 */
function _mm_ffmpeg_video_thumbnail(&$item, $configuration) {
  // check if the incoming file exists
  mm_ffmpeg_file_exists($item);
  if ($item['status'] === 0) {
    return;
  }

  $output_file  = file_create_filename(
    str_replace(' ', '_', basename($item['harvest']['file'])) .'.thumb'. $configuration['cid'] .'.'. $configuration['thumb_format'],
    media_mover_api_dir_path('ffmpeg/thumbnails/'. $configuration['cid'])
  );

  // get input file
  $options[] = '-i '. escapeshellarg($item['harvest']['file']);
  // set frame time
  $options[] = '-vframes 1 -ss '. $configuration['thumb_time']  .' -an';
  // set codec
  $options[] = '-vcodec mjpeg -f rawvideo -s '. $configuration['thumb_dimensions'];
  // add output file
  $options[] = escapeshellarg($output_file);

  $command = implode(' ', $options);
  $output = _mm_ffmpeg_run_command($command);

  if (!_mm_ffmpeg_error_check($output, $item, $configuration, $command)) {
    $item['status'] = 0;
    return;
  }
  if (!file_exists($output_file)) {
    watchdog('media_mover', 'FFmpeg failed to create %file.', array('%file' => $output_file), WATCHDOG_ERROR);
    $item['status'] = 0;
  }

  // run media mover's file perms
  media_mover_api_set_file_perm($output_file);

  $link = l('node '. $item['nid'], "node/$item[nid]/edit");
  watchdog('media_mover', 'FFmpeg created %file.', array('%file' => $output_file), WATCHDOG_INFO, $link);

  // add info to $file
  $item['process']['file'] = $output_file;

  // set file type to thumb
  $item['type'] = 'thumb'; // @@@ WTF?
}

/**
 * processes the incoming file
 * @ TODO test watermark
 * @param $file is a file array
 * @param $configuration is the configuration that governs this process
 * returns the file array
 */
function _mm_ffmpeg_video(&$item, $configuration) {
  // check if the incoming file exists
  mm_ffmpeg_file_exists($item);
  if ($item['status'] === 0 ) {
    return;
  }

  $path_to_wm = variable_get('mm_ffmpeg_wm', '/opt/ffmpeg/current/lib/vhook/watermark.so');

  // check to see if this file can be decoded
  if (!_mm_ffmpeg_can_decode($item['harvest']['file'])) {
    $link = l('node '. $item['nid'],  "node/$item[nid]/edit");
    watchdog('media_mover', 'FFmpeg can not decode %file. !link', array('%file' => $item['harvest']['file'], '!link' => l('file', "admin/content/media_mover/file/$item[mmfid]/edit")), WATCHDOG_NOTICE, $link);
    $item['status'] = 0;
    return;
  }

  // build the ffmpeg command structure out
  $options = array();

  // input file
  $options[] = '-i '. escapeshellarg($item['harvest']['file']);

  // build the watermark config
  if ($configuration['ffmpeg_video_wm']) {
   $options[] = '-vhook '. escapeshellarg($path_to_wm) .' -f '. escapeshellarg($configuration['ffmpeg_video_wm_file']);
  }

   // use a specifc codec?
   if ($configuration['ffmpeg_acodec']) {
     $options[] = '-acodec '. $configuration['ffmpeg_acodec'];
   }
   else {
     $options[] = '-acodec mp3';
   }

  // build the audio config
  if ($configuration['ffmpeg_audio_advanced']) {

    // use a specific sample rate?
    if ($configuration['ffmpeg_audio_ar'] ) {
      $options[] = '-ar '. $configuration['ffmpeg_audio_ar'];
    }

    // use a specific bit rate?
    if ($configuration['ffmpeg_audio_ab']) {
      $options[] = '-ab '. $configuration['ffmpeg_audio_ab'];
    }
  }

  // build the video config
  if ($configuration['ffmpeg_video_advanced']) {

    // is codec set?
    if ($configuration['ffmpeg_vcodec']) {
      $options[] = '-vcodec '. $configuration['ffmpeg_vcodec'];
    }

    // is frame size set?
    if ($configuration['ffmpeg_video_size']) {
      $options[] = '-s '. $configuration['ffmpeg_video_size'];
    }

    // is the bit rate set?
    if ($configuration['ffmpeg_video_br']) {
      $options[] = '-b '. $configuration['ffmpeg_video_br'];
    }

    // is frame rate set?
    if ($configuration['ffmpeg_video_fps']) {
      $options[] = '-r '. $configuration['ffmpeg_video_fps'];
    }
  }

  // implement truncating
  if ($configuration['ffmpeg_time_advanced']) {
    $options[] = '-t '. $configuration['ffmpeg_time'];
  }

  // add the output file
  // @ TODO make sure that the output file has the appropriate extension.
  $output_file  = file_create_filename(
    str_replace(' ', '_', basename($item['harvest']['file'])) .'.'. $configuration['ffmpeg_output_type'],
    media_mover_api_dir_path('ffmpeg/converted/'. $configuration['cid'])
  );

  // add the output file
  $options[] = escapeshellarg($output_file);

  $command = implode(' ', $options);

  // run ffmpeg
  $output = _mm_ffmpeg_run_command($command);

  // check and see if any errors were reported
  if (!_mm_ffmpeg_error_check($output, $item, $configuration, $command)) {
    $item['status'] = 0;
  }

  $link = l('node '. $item['nid'],  "node/$item[nid]/edit");
  watchdog('media_mover', 'FFmpeg converted %file', array('%file' => $output_file), WATCHDOG_INFO, $link);

  // run media mover's file perms
  media_mover_api_set_file_perm($output_file);

  // add info to $file
  $item['process']['file'] = $output_file;
  $item['data']['file']['mime'] = 'image/'. $configuration['ffmpeg_output_type'];
  $item['data']['file']['drupal_path'] = $output_file;
  $item['status'] = 1;
}

/**
 * Run a ffmpeg command and return the output.
 */
function _mm_ffmpeg_run_command($options) {
  $command = variable_get('mm_ffmpeg_path', '/opt/ffmpeg/current/bin/ffmpeg') .' '. $options;
  watchdog('media_mover', 'Running FFmpeg command: %command', array('%command' => $command), WATCHDOG_DEBUG);
  ob_start();
  passthru($command ." 2>&1", $command_return );
  $command_output = ob_get_contents();
  ob_end_clean();
  return $command_output;
}

/**
 * gets an array of format types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 */
function _mm_ffmpeg_get_file_formats($ret = null) {
  static $rows, $encode_formats, $decode_formats;

  // only parse if this hasn't been set
  if (!is_array($rows)) {
    $formats = _mm_ffmpeg_run_command('-formats');

    // slice up the format output
    $startpos = strpos($formats, 'File formats:');
    $endpos = strpos($formats, 'Codecs:');
    $formats = substr($formats, $startpos, $endpos);

    //remove the header
    $formats = str_replace('File formats:', '', $formats);

    $formats = explode("\n", $formats);

    $decode_formats = array();
    $encode_formats = array();

    foreach ($formats as $format) {
      // only run on lines longer than 3
      if (!strlen($format) < 3) {
        // codec names seem to always be here
        $pattern = '/\s+/';
        $replace = ' ';
        $type = preg_replace($pattern, $replace, substr($format, 4, 19));
        $type = explode(' ', $type);

        if (count($type) < 2) {
          // Skip incomplete lines.
          continue;
        }
        $a_format['type'] = $type[0];
        $a_format['name'] = $type[1];

        if (substr($format, 1, 1) == 'D') {
          $a_format['decode'] = t('yes');
          $decode_formats[] = $a_format['type'];
        }
        else {
          $a_format['decode'] = t('no');
        }

        if (substr($format, 2, 1) == 'E') {
          $a_format['encode'] = t('yes');
          $encode_formats[] = $a_format['type'];
        }
        else {
          $a_format['encode'] = t('no');
        }

        $a_format['description'] = substr($format, 20);
        if ($a_format['description']) {
          $rows[] = $a_format;
        }
      }
    }
  }

  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  }
}

/**
 * checks an incoming file path extension to
 * see if it can be decoded
 *
 * @param $file is a full system filepath
 */
function _mm_ffmpeg_can_decode($path) {
  $file_types = _mm_ffmpeg_get_file_formats('decode');

  $path_parts = pathinfo($path);

  $exception = false;
  // exception handling
  // WMVs are sometimes asf files
  if ($path_parts['extension'] == 'wmv') {
    $exception = 'asf';
  }

  if ($file_types) {
    foreach ($file_types as $file_type) {
      if ($path_parts['extension']) {
        if (stristr($file_type, $path_parts['extension']) || stristr($file_type, $exception)) {
          return true;
        }
      }
    }
  }
  return false;
}

/**
 * gets an array of codec types usable on this system
 * this should probably be smoothed out so that it doesn't rely on
 * text so much
 * @ TODO this needs to be rethought to pass params right
 * @output is the output text from the ffmpeg -formats
 */
function _mm_ffmpeg_get_codecs($ret = null) {
  $rows = array();
  // get formats from ffmpeg
  $output =  _mm_ffmpeg_run_command('-formats');

  // parse the list
  // we know where the codecs are by looking at the output of ffmpeg -formats
  $codecs_formats_pos = strpos($output, "Codecs:");
  $codecs_formats_pos_end = strpos($output, "upported file protocols:");

  $video_formats = substr($output, $codecs_formats_pos, ($codecs_formats_pos_end - $codecs_formats_pos));

  $video_formats = str_replace('Codecs:', '', $video_formats);
  $video_formats = preg_split('/[\n\r]+/', $video_formats);

  foreach ($video_formats as $format) {

    // codec names seem to always be here
    $a_format['name'] = substr($format, 8);

    if (substr($format, 3, 1) == 'A') {
      $a_format['type'] = t('audio');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['type'] = t('video');
    }

    // get the decode
    if (substr($format, 1, 1) == 'D') {
      $a_format['decode'] = t('yes');
      $decode_formats[] = $a_format['name'];
    }
    else {
      $a_format['decode'] = t('no');
    }

    // get the encode
    if (substr($format, 2, 1) == 'E') {
      $a_format['encode'] = t('yes');
      $encode_formats[] = $a_format['name'];
    }
    else {
      $a_format['encode'] = t('no');
    }

    if ($a_format['name']) {
      $rows[] = $a_format;
    }
    $a_format = null;
  }

  switch ($ret) {
    case 'encode':
      return $encode_formats;
    break;
    case 'decode':
      return $decode_formats;
    break;
    default:
      return $rows;
    break;
  }
}

/**
 * checks to see if a file exists
 * @param $item A media mover item.
 */
function mm_ffmpeg_file_exists(&$item) {
  // make sure file exists
  if (!file_exists($item['harvest']['file']) ) {
    $link = l("node ". $item['nid'],  "node/$item[nid]/edit");
    watchdog('media_mover', 'File %file did not exist for FFmpeg conversion!', array('%file' => $item['harvest']['file']), WATCHDOG_NOTICE, $link);
    $item['status'] = 0;
  }
}

/**
 * checks ffmpeg's output for errors and tries to handle them some way
 * @param $output is the output from a shell command
 * @param $item A media mover item.
 * @param $configuration is the configuration being run
 * @param $watchdog is boolean, log errors to drupal's watchdog
 * @return true if no errors, false if errors
 */
function _mm_ffmpeg_error_check($output, &$item, $configuration, $command, $watchdog = true) {
  // build the error conditions
  // these are all pulled by hand at this point
  $errors = array(
    '/Segmentation fault/i',
    '/Unsupported/i',
   //'/Error while/i', // this is not necessarily fatal
    '/Unable for find a suitable output format for/i',
    '/Incorrect frame size/i',
    '/Unsupported codec/i',
    '/Unknown encoder/i',
    '/Could not write header/i',
  );

  // check for error conditions
  foreach ($errors as $error) {
    if ($match = preg_match($error, $output)) {
      _mm_ffmpeg_error_log($output, $item, $configuration, $command);
      return false;
    }
  }
  return true;
}

/**
 * takes error conditions from the conversion process and deals
 * with them according to the admin configuration
 *
 * @param $output is the command line output
 * @param $file is the file that failed
 * @param $configuration is the configuration that was running
 */
function _mm_ffmpeg_error_log($output, &$item, $configuration, $command) {
  watchdog(
    'media_mover',
    "Media Mover ff_mpeg had an error converting this file: @file. \nThe command was: @command",
    array(
      '@file' => $item['harvest']['file'],
      '@command' => $command,
    ),
    WATCHDOG_NOTICE, // @@@ 6.x state it maps to better?
    url("node/$item[nid]/edit") // @@@ nid no longer the right thing due to file table in 6.x?
  );

  // notify admin
  if ($emails = variable_get('ffmpeg_error_email', null)) {
    $emails = explode(',', $emails);
    foreach ($emails as $email) {
      $email = trim($email);
      if (valid_email_address($email)) {
        drupal_mail('mm_ffmpeg', 'admin_notice', $email, language_default(), array('file' => $item));
      }
    }
  }

  // send uploader a message
  if (variable_get('ffmpeg_error_user', null)) {
    if ($item['uid']) { // @@@ Test whether this works.
      $account = user_load($item['uid']);
      drupal_mail('mm_ffmpeg', 'user_notice', $account->mail, user_preferred_language($account), array('account' => $account, 'file' => $item));
    }
  }
  // Flag error.
  $item['status'] = 0;
}

/**
 * Implementation of hook_mail().
 */
function mm_ffmpeg_mail($key, &$message, $params) {
  $language = $message['language'];
  $l = $language->language;
  switch ($key) {
    case 'admin_notice':
      $message['subject'] = t('FFmpeg conversion problem', array(), $l);
      $message['body'][] = t('There was a problem converting this file:', array(), $l);
      $message['body'][] = $file['harvest']['file'];
      $message['body'][] = t('FFmpeg said:', array(), $l);
      $message['body'][] = $output;
      $message['body'][] = t('File data:', array(), $l);
      $message['body'][] = print_r($params['file'], true); // @@@ What does this look like in an email, exactly?
      break;

    case 'user_notice':
      $account = $params['account'];
      $variables = user_mail_tokens($account, $language);
      $file_parts = pathinfo($params['file']['harvest']['file']);
      $file = $file_parts['basename'] .'.'. $file_parts['extension'];
      $message['subject'] = t('Problem with your uploaded file', $variables, $l);
      $message['body'][] = "$account->name,";
      $message['body'][] = t("We're sorry, but we're having a hard time converting a file you uploaded.", $variables, $l);
      $message['body'][] = t("We'll take a look at the file and see if we can help, but you can always try converting to a standard format and uploading again.", $variables, $l);
      $message['body'][] = t('Sorry, and thanks for using our site.', $variables, $l);
      break;
  }
}

/**
 * checks to make sure that FFmpeg is in the path
 */
function mm_ffmpeg_is_path() {
  if (!_mm_ffmpeg_run_command('')) {
    return false;
  }
  return true;
}

/**
 * displays a table of the supported ffmpeg file formats
 */
function _mm_ffmpeg_formats_data_display() {
  $header = array(t('name'), t('type'), t('decode'), t('encode'), t('description') );
  $output = theme('table', $header, _mm_ffmpeg_get_file_formats() );
  return $output;
}

/**
 * displays a table of the ffmpeg encoding and decoding options
 */
function _mm_ffmpeg_get_codecs_display() {
  $header = array(t('codec'), t('codec type'), t('decode'), t('encode'));
  $output = theme('table', $header, _mm_ffmpeg_get_codecs() );
  return $output;
}

/* ************************************ */
/* configuration */
/* ************************************ */

/**
 * builds the admin form
 */
function mm_ffmpeg_admin() {

  $form['mm_ffmpeg'] = array(
    '#type' => 'fieldset',
    '#title' => t("FFmpeg"),
    '#collapsed' => true,
    '#collapsible' => true,
  );

  $form['mm_ffmpeg']['mm_ffmpeg_about'] = array(
    '#type' => 'fieldset',
    '#title' => t('About FFmpeg installation'),
    '#collapsible' => true,
    '#collapsed' => true,
  );

  $form['mm_ffmpeg']['mm_ffmpeg_about']['mm_ffmpeg_version'] = array(
    '#type' => 'item',
    '#title' => t('FFmpeg version'),
    '#value' =>  '<blockquote>'. _mm_ffmpeg_run_command(' -v') .'</blockquote>',
    '#description' => t('Version of FFmpeg running on your system'),
  );

  $form['mm_ffmpeg']['mm_ffmpeg_about']['mm_ffmpeg_formats'] = array(
    '#type' => 'item',
    '#title' => t('Supported file formats'),
    '#value' =>  _mm_ffmpeg_formats_data_display(),
    '#description' => t('File formats that the installed version of FFmpeg supports.'),
  );

  $form['mm_ffmpeg']['mm_ffmpeg_about']['mm_ffmpeg_codecs'] = array(
    '#type' => 'item',
    '#title' => t('Installed codecs'),
    '#value' => _mm_ffmpeg_get_codecs_display(),
    '#description' => t('FFmpeg was either compiled with these codecs, or these are the codecs available on your system'),
  );

  $form['mm_ffmpeg']['mm_ffmpeg_path'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg path'),
    '#default_value' => variable_get('mm_ffmpeg_path', '/opt/ffmpeg/current/bin/ffmpeg'),
    '#description' => t("Absolute path to the FFmpeg exeutable."),
  );

  $form['mm_ffmpeg']['mm_ffmpeg_wm'] = array(
    '#type' => 'textfield',
    '#title' => t('FFmpeg watermark path'),
    '#default_value' => variable_get('mm_ffmpeg_wm', '/opt/ffmpeg/current/lib/vhook/watermark.so'),
    '#description' => t("Absolute path to the FFmpeg vhook watermark exeutable."),
  );

  $form['mm_ffmpeg']['errors'] = array(
    '#type' => 'fieldset',
    '#title' => t('Error handling'),
    '#collapsible' => true,
    '#collapsed' => true,
  );

  $form['mm_ffmpeg']['errors']['ffmpeg_error_email'] = array(
    '#type' => 'textfield',
    '#title' => t('Email encoding errors'),
    '#default_value' => variable_get('ffmpeg_error_email', ''),
    '#description' => t('Comma seperated list of email addresses to notify when an encoding error happens.'),
  );

  // @ TODO this hasn't been supported yet I think
  $form['mm_ffmpeg']['errors']['ffmpeg_error_user'] = array(
    '#type' => 'checkbox',
    '#title' => t('Notify uploader'),
    '#default_value' => variable_get('ffmpeg_error_user', ''),
    '#description' => t('Notify the uploader (if possible) that their upload could not be converted.'),
  );
  return $form;
}

/**
 * builds the edit config form
 */
function mm_ffmpeg_config($action, $configuration) {
  if (!mm_ffmpeg_is_path()) {
    drupal_set_message(t('Sorry, could not find FFmpeg, please go to: !link', array('!link' => l(t('Media Mover Settings'), 'admin/media_mover/settings'))), 'error');
  }
  else {
    $form['mm_ffmpeg'] = array(
      '#type' => 'fieldset',
      '#title' => t("FFmpeg video conversion settings"),
      '#collapsed' => false,
    );

    // get the output formats
    $outputs = _mm_ffmpeg_get_file_formats('encode');
    foreach ($outputs as $output) {
      $formats[$output] = $output;
    }
    $form['mm_ffmpeg']["ffmpeg_output_type"] = array(
      '#type' => 'select',
      '#title' => t('Output format'),
      '#options' => $formats,
      '#default_value' => $configuration['ffmpeg_output_type'] ? $configuration['ffmpeg_output_type'] : 'flv',
      '#description' => t('Select the output format. Note, some formats may require setting audio or video codecs.'),
     );

    $form['mm_ffmpeg']['audio'] = array(
      '#type' => 'fieldset',
      '#title' => t('Audio conversion settings'),
      '#collapsed' => $configuration['ffmpeg_audio_advanced'] ? false : true,
      '#collapsible' => true,
    );
    $form['mm_ffmpeg']['audio']["ffmpeg_audio_advanced"] = array(
      '#type' => 'checkbox',
      '#title' => t('Use advanced settings'),
      '#description' => t('Use the advanced audio encoding options. If this is off, FFmpeg will encode mp3 at 64bit, 44.1khz.'),
      '#default_value' => $configuration['ffmpeg_audio_advanced'],
    );
    // @@@ These need to have a k appended apparently? Maybe in the actual invocation?
    $bit_rates = array(8 => 8, 16 => 16, 32 => 32, 64 => t('64k (default)'), 128 => 128, 256 => 256);
    $form['mm_ffmpeg']['audio']["ffmpeg_audio_ab"] = array(
      '#type' => 'select',
      '#title' => t('Audio bit rate'),
      '#options' => $bit_rates,
      '#default_value' => $configuration['ffmpeg_audio_ab'] ? $configuration['ffmpeg_audio_ab'] :  64,
      '#description' => t("Audio bit rate for conversion."),
    );
    $sample_rates = array('11025' => '11khz', '22050' => '22khz', '32000' => '34khz', '44100' => '44.1khz (default)' );
    $form['mm_ffmpeg']['audio']["ffmpeg_audio_ar"] = array(
      '#type' => 'select',
      '#title' => t('Audio sample rate'),
      '#options' => $sample_rates,
      '#default_value' => $configuration['ffmpeg_audio_ar'] ? $configuration['ffmpeg_audio_ar'] : 44100,
      '#description' => t('Audio sample rate for conversion.'),
    );

    $vcodecs = array( '' => 'default');

    // get list of avaiable audio and video codecs
    $codec_list = _mm_ffmpeg_get_codecs();
    $acodecs = array();
    $vcodecs = array();
    if ($codec_list) {
      foreach ($codec_list as $codec) {
        if ($codec['encode'] == 'yes') {
          if ($codec['type'] == 'audio') {
            $acodecs[$codec['name']] = $codec['name'];
          }
          else if($codec['type'] == 'video') {
            $vcodecs[$codec['name']] = $codec['name'];
          }
        }
      }
    }

    // overriding the hand backs from ffmpeg until a better way of matching up the supported
    // codecs and the command line args becomes apparent
    array_unshift($acodecs, array('mp3' => t('lame mp3 (alternate name)')));
    array_unshift($acodecs, array('libmp3lame' => t('lame mp3 (default)')));
    $form['mm_ffmpeg']['audio']['ffmpeg_acodec'] = array(
      '#type' => 'select',
      '#title' => t('Audio codec'),
      '#options' => $acodecs,
      '#default_value' => $configuration['ffmpeg_acodec'] ? $configuration['ffmpeg_acodec'] : 'mp3' ,
      '#description' => t('Select the codec for the output format. Please note, you may need to pick an appropriate video codec for the transcoding. WARNING the codec support right now is experimental. Things may not work as expected.'),
     );

    $form['mm_ffmpeg']['video'] = array(
      '#type' => 'fieldset',
      '#title' => t('Video conversion settings'),
      '#collapsed' => $configuration['ffmpeg_video_advanced'] ? false : true,
      '#collapsible' => true,
    );
    $form['mm_ffmpeg']['video']['ffmpeg_video_advanced'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use advanced settings'),
      '#description' => t('Use the advanced video encoding options. If this is off, FFmpeg will encode flv at 200 kb/s, 128x96, 25fps.'),
      '#default_value' => $configuration['ffmpeg_video_advanced'],
    );

    // video frame size
    $frame_size = drupal_map_assoc(array('128x96', '176x144', '320x240', '352x288', '704x576'));
    $form['mm_ffmpeg']['video']['ffmpeg_video_size'] = array(
      '#type' => 'select',
      '#title' => t('Video frame size'),
      '#options' => $frame_size,
      '#default_value' => $configuration['ffmpeg_video_size'],
      '#description' => t('Dimensions of the converted video.'),
    );

    $fps_rates = array(0 => 'default', 10 => 10, 15 => 15, 20 => 20, 25 => '25 (default)', 29.97 => 29.97);
    $form['mm_ffmpeg']['video']['ffmpeg_video_fps'] = array(
      '#type' => 'select',
      '#title' => t('Video fps rate'),
      '#options' => $fps_rates,
      '#default_value' => $configuration['ffmpeg_video_fps'] ? $configuration['ffmpeg_video_fps'] : 25,
      '#description' => t("Sets the frames per second of the converted video."),
    );

    $bit_rates = array('50k' => '50kps', '100k' => '100kps', '150k' => '150kps', '200k' => '200kps', '250k' => '250kps', '300k' => '300kps', '500k' => '500kps', '750k' => '750kps', '1000k' => '1000kps', '1250k' => '1250kps', '1500k' => '1500kps', '2000k' => '2000kps');
    $form['mm_ffmpeg']['video']['ffmpeg_video_br'] = array(
      '#type' => 'select',
      '#title' => t('Video bit rate'),
      '#options' => $bit_rates,
      '#default_value' => $configuration['ffmpeg_video_br'],
      '#description' => t('Target the output video to this bit rate.'),
    );

    $form['mm_ffmpeg']['video']['ffmpeg_vcodec'] = array(
      '#type' => 'select',
      '#title' => t('Video codec'),
      '#options' => $vcodecs,
      '#default_value' => $configuration['ffmpeg_vcodec'],
      '#description' => t('Select the codec for the output format. Please note, you may need to pick an appropriate audio codec for the transcoding.'),
    );

    $form['mm_ffmpeg']['time'] = array(
      '#type' => 'fieldset',
      '#title' => t('Video duration'),
      '#collapsed' => $configuration['ffmpeg_time_advanced'] ? false : true,
      '#collapsible' => true,
    );
    $form['mm_ffmpeg']['time']['ffmpeg_time_advanced'] = array(
      '#type' => 'checkbox',
      '#title' => t('Truncate the output video'),
      '#description' => t('Use this to limit the length of the output video. Useful for making a video teaser'),
      '#default_value' => $configuration['ffmpeg_time_advanced'],
    );
    $times = array(30 => "30 seconds", 60 => "1 minute", 120 => "2 minutes", 300 => "5 minutes");
    $form['mm_ffmpeg']['time']['ffmpeg_time'] = array(
      '#type' => 'select',
      '#title' => t('Video length'),
      '#options' => $times,
      '#default_value' => $configuration['ffmpeg_time'],
      '#description' => t("Set the max video length time."),
    );

    $form['mm_ffmpeg']['watermark'] = array(
      '#type' => 'fieldset',
      '#title' => t('Video watermark settings'),
      '#collapsed' => $configuration['ffmpeg_video_wm'] ? false : true,
      '#collapsible' => true,
    );
    $form['mm_ffmpeg']['watermark']['ffmpeg_video_wm'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use watermark'),
      '#description' => t('Use a file to watermark the converted video.'),
      '#default_value' => $configuration['ffmpeg_video_wm'],
    );
    // @ TODO make this a file upload
    $form['mm_ffmpeg']['watermark']['ffmpeg_video_wm_file'] = array(
      '#type' => 'textfield',
      '#title' => t('Path to file'),
      '#description' => t('Absolute path to the watermark file.'),
      '#default_value' => $configuration['ffmpeg_video_wm_file'],
    );


    $form['mm_ffmpeg']['file'] = array(
      '#type' => 'fieldset',
      '#title' => t('File settings'),
      '#collapsed' => true,
      '#collapsible' => true,
    );

    $form['mm_ffmpeg']['file']['ffmpeg_output_perms'] = array(
      '#type' => 'textfield',
      '#title' => t('Output file permissions'),
      '#description' => t('Set the permissions on the output file. Default is 0644.'),
      '#default_value' => $configuration['ffmpeg_output_perms'] ? $configuration['ffmpeg_output_perms'] : '0644' ,
      '#size' => 4,
    );
  }
  return $form;
}

/**
 * builds the edit config form for thumbnail
 */
function mm_ffmpeg_config_thumb($action, $configuration) {
  if (!mm_ffmpeg_is_path()) {
    drupal_set_message(t('Sorry, could not find FFmpeg, please go to: !link', array('!link' => l(t('Media Mover Settings'), 'admin/media_mover/settings'))), 'error');
  }
  else {
    $form['mm_ffmpeg_thumb'] = array(
      '#type' => 'fieldset',
      '#title' => t("FFmpeg Thumbnail Creation"),
      '#collapsed' => false,
    );

    // @ TODO make this use the same sizes as the conversion
    $form['mm_ffmpeg_thumb']['thumb_dimensions'] = array(
      '#type' => 'textfield',
      '#title' => t('Thumbnail output dimensions'),
      '#default_value' => $configuration['thumb_dimensions'] ? $configuration['thumb_dimensions'] : '320x240',
      '#description' => t("Thumbnail image output dimensions, in the form <em>320x240</em>."),
    );

    $form['mm_ffmpeg_thumb']['thumb_time'] = array(
      '#type' => 'textfield',
      '#title' => t('Thumbnail time'),
      '#default_value' => $configuration['thumb_time'] ? $configuration['thumb_time'] : '00:00:02' ,
      '#description' => t('Take the thumnail screen shot from this time, in the form <em>00:00:02</em>.'),
    );

    $options = array('jpg' => 'jpg', 'gif' => 'gif', 'png' => 'png');
    $form['mm_ffmpeg_thumb']['thumb_format'] = array(
      '#type' => 'select',
      '#title' => t('Thumbnail format'),
      '#options' => $options,
      '#default_value' => $configuration['thumb_format'] ? $configuration['thumb_format'] : 'jpg',
      '#description' => t('Format for the thumbnail output'),
    );
  }
  return $form;
}
